Category 	Item_Name	Notes	Kotlin	TypeScript	Swift	Scala	Go	Python	Java	Javascript	Ruby	C++	C#	R	Shell	PHP	Dart	Rust	Perl	VB	OC	Lua
BASIC	entry_point		fun main() {     println("Hello, World!") }	function main() {     console.log("Hello, World!"); }  main();																		
	hello_world		println("Hello, world!")	console.log("Hello, world!");																		
	variables_constants		var myVariable = 42 myVariable = 50 val myConstant = 42	let myVariable = 42; myVariable = 50; const myConstant = 42;																		
	explicit_types		val explicitDouble: Double = 70.0 // Boolean // Byte, Short, Int, Long, Float, Double, UByte, UShort, UInt, ULong // String // Any, Unit // Nothing // dynamic external fun require(module:String): dynamic	const explicitDouble: number = 70; // boolean // number, bigint // string // any, void // never // undefined, unknown, null, Symbol, union: string|number, string|object declare const welcome: any;																		
	tye_inference		val label = "The width is " val width = 94 val widthLabel = label + width	const label = "The width is "; const width = 94; const widthLabel = label + width;																		
	type_aliases		typealias Name = String; typealias NameResolver = () -> String;	type Name = string; type NameResolver = () => string;																		
	smart_casts		fun demo(x: Any) {     if (x is String) {         print(x.length) // x is automatically cast to String     } }	function foo2(arg: unknown) {   if (typeof arg === "string") {     // We know this is a string now.     console.log(arg.toUpperCase());   } }																		
	equality		//Structural Equality (‘==’), Referential equality (‘===’), .equals method data class User(val id: Int, val nick: String)  fun testEquals() {     val first: Any = User(1, "linux_china")     val second: Any = User(1, "linux_china")     println(first == second)  //true     println(first === second)  //false, Referential different     println(first.equals(second)) //true }	//Equals Operator ( == ), Strict Equals Operator ( === ) let a: any = 10; let b: any = "10" console.log(a == b);  //true console.log(a == b);  //true console.log(a === b); //false, type different																		
	nullable_nonnull_nullish_coalescing		val name1: String = "xx" var name2: String? = null  fun testNullable() {     name2.length //illegal     name2?.length //nullable check     name2!!.length //you know that }  // Elvis Operator val name3 = name2 ?: "good";	let name1: string = "xx" let name2: string | null = null  name2.length //null check validation let len = name2?.length //nullable check name2!.length //you know that  //Nullish Coalescing let x1 = name2 ?? "default value";																		
	string_interpolation		val apples = 3 val oranges = 5 val fruitSummary1 = "I have ${apples + oranges} pieces of fruit." val fruitSummary2 = """I have ${apples + oranges} pieces of fruit.""" val fruitSummary3 = html("""I have ${apples + oranges} pieces of fruit.""")	const apples = 3; const oranges = 5; const fruitSummary1 = `I have ${apples + oranges} pieces of fruit.`; const fruitSummary2 = html`I have ${apples + oranges} pieces of fruit.`; 																		
	range_operator		val names = arrayOf("Anna", "Alex", "Brian", "Jack") val count = names.count() for (i in 0..count - 1) {     println("Person ${i + 1} is called ${names[i]}") } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack	import * as _ from 'lodash'; const names = ["Anna", "Alex", "Brian", "Jack"]; const count = names.length; for (let i of _.range(0, count)) {     console.log(`Person ${i + 1} is called ${names[i]}`) } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack																		
	inclusive_range_operator		for (index in 1..5) {     println("$index times 5 is ${index * 5}") } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25	import * as _ from 'lodash';  for(let index of _.range(1, 6)) {     console.log(`${index} times 5 is ${index * 5}`) } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25																		
COLLECTIONS	arrays_list		fun main12() {     val shoppingList = arrayOf(         "catfish", "water",         "tulips", "blue paint"     )     shoppingList[1] = "bottle of water"     val freezeList = listOf("first", "second", "third")     val mutableList = mutableListOf("first", "second", "third") }	let shoppingList = ["catfish", "water",     "tulips", "blue paint"]; shoppingList[1] = "bottle of water";																		
	set		val set1 = setOf(1 , 2 , 3 , 4 , 3) val mutableSet = mutableSetOf(1 , 2 , 3 , 4 , 3);	let mySet = new Set(); //ES2015 mySet.add(1); mySet.delete(1)																		
	stream_sequence		val wordsSequence = listOf("one", "two", "three", "four").asSequence() val list2 = wordsSequence     .filter { println("filter: $it"); it.length > 3 }     .map { println("length: ${it.length}"); it.length }     .toList()	let words = ["catfish", "water", "tulips", "blue paint"]; let list2 = words.filter(word => {     return word.length > 3; }).map(word => {     return word.length });																		
	map		val occupations = mutableMapOf(     "Malcolm" to "Captain",     "Kaylee" to "Mechanic" ) occupations["Jayne"] = "Public Relations"	let occupations = {     "Malcolm": "Captain",     "Kaylee": "Mechanic", }; occupations["Jayne"] = "Public Relations";																		
	tuple		// data class as Tuple in Kotlin data class GasPrices(val a: Double, val b: Double, val c: Double)  fun main7() {     val price = GasPrices(3.59, 3.69, 3.79)     val (a, b, _) = price }	type GasPrices = [number, number, number]  //Labeled Tuple type Range = [start: number, end: number];  function main4() {     let price: GasPrices = [3.59, 3.69, 3.79]     let [a, b, c] = price; }																		
	filter_map_reduce		fun main13() {     val shoppingList = arrayOf("catfish", "water", "tulips", "blue paint")     shoppingList.filter { it.startsWith("c") }         .map { it.length }         .reduce { acc, i -> acc + i }      shoppingList.filter { it.startsWith("c") }         .forEach(::println) }	let shoppingList2 = ["catfish", "water", "tulips", "blue paint"];  shoppingList2     .filter(item => item.startsWith("c"))     .map(item => item.length)     .reduce((acc, item) => acc + item)  shoppingList2     .filter(item => item.startsWith("c"))     .forEach(item => {         console.log(item)     })																		
	empty_collections		val emptyArray = arrayOf<String>() val emptyMap = mapOf<String, Float>()	const emptyArray: string[]; const emptyDictionary: {[key: string]: number};																		
FUNCTIONS	functions		fun greet(name: String, day: String): String {     return "Hello $name, today is $day." } greet("Bob", "Tuesday")	function greet(name: string, day: string): string {     return `Hello ${name}, today is ${day}.` } greet("Bob", "Tuesday");																		
	variable_number_of_arguments		fun sumOf(vararg numbers: Int): Int {     var sum = 0     for (number in numbers) {         sum += number     }     return sum }  fun main3() {     sumOf(42, 597, 12)     // sumOf() can also be written in a shorter way:     fun sumOf(vararg numbers: Int) = numbers.sum() }	function sumOf(...numbers: number[]): number{     let sum = 0;     for (let number of numbers) {         sum += number;     }     return sum; } sumOf(42, 597, 12);																		
	function_type		fun makeIncrementer(): (Int) -> Int {     val addOne = fun(number: Int): Int {         return 1 + number     }     return addOne } val increment = makeIncrementer() increment(7)  // makeIncrementer can also be written in a shorter way: fun makeIncrementer() = fun(number: Int) = 1 + number	function makeIncrementer():(number) => number{     function addOne(number: number): number {         return 1 + number;     }     return addOne } let increment = makeIncrementer(); increment(7);  // makeIncrementer can also be written in a shorter way: let makeIncrementer = () => (number: number) => 1 + number;																		
	functional_interface		fun interface IntPredicate {     fun accept(i: Int): Boolean }  val isEven = IntPredicate { it % 2 == 0 }  fun main() {     println("Is 7 even? - ${isEven.accept(7)}") }	interface SearchFunc {   (source: string, subString: string): boolean; }  let mySearch: SearchFunc;  mySearch = function (source: string, subString: string) {   let result = source.search(subString);   return result > -1; };																		
	lambda_arrow_function		//lambda val printText = { text: String ->     println(text) }	//arrow function let printText = (text: string) => {     console.log(text) }																		
	named_arguments		fun area(width: Int, height: Int) = width * height area(width = 2, height = 3)  // This is also possible with named arguments area(2, height = 2) area(height = 3, width = 2)	function area({width, height}:{width:number, height:number}):number {     return width * height; } area({width: 2, height: 3});																		
	functions_generics		fun  identity(value: T): T {     return value }  val str = identity("Hello")	function identity(value: T): T {     return value; }  let str: string = identity("Hello");																		
	generator_function		val sequence2 = sequence {     val start = 0     // yielding a single value     yield(start)     // yielding an iterable     yieldAll(1..5 step 2)     // yielding an infinite sequence     yieldAll(generateSequence(8) { it * 3 }) }  println(sequence2.take(7).toList()) // [0, 1, 3, 5, 8, 24, 72]	function* counter(max: number): Generator {     let i = 0;     while (i < max) {         if (yield i++) {             break;         }     } }  for (let num of counter(3)) {     console.log(num); }																		
	async_generator_function		import kotlinx.coroutines.delay import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flow  fun simple(): Flow = flow { // flow builder     for (i in 1..3) {         delay(100) // pretend we are doing something useful here         emit(i) // emit next value     } }  fun main() = runBlocking {     // Collect the flow     simple().collect { value -> println(value) } }	// async generator function async function* g() {   yield 1;   await sleep(100);   yield* [2, 3];   yield* (async function*() {     await sleep(100);     yield 4;   })(); }  async function f() {   //The for-await-of Statement   for await (const x of g()) {     console.log(x);   } }																		
	optional_default_value_params		//Optional Parameters by default value fun sayHello(name: String = "") {  }  fun main4() {     sayHello()     sayHello("Jackie") }	// Optional Parameters function sayHello(hello?: string) {     console.log(hello); }  //default-initialized parameters function buildName(firstName: string, lastName = "Smith") {     return firstName + " " + lastName; }  sayHello() sayHello("Jackie")  buildName("Jack") buildName("Jack", "Ma")																		
	method_extension		import kotlin.js.RegExp  fun String.isEmailValid(): Boolean {     val pattern = RegExp("^[\\w.-]+@([\\w\\-]+\\.)+[A-Z]{2,8}$", "i")     return pattern.test(this) }	declare interface String {     isEmailValid(): boolean; }  String.prototype.isEmailValid = function (this: string): boolean {     let re = new RegExp("^[\\w.-]+@([\\w\\-]+\\.)+[A-Z]{2,8}$", 'i');     return re.test(this); };																		